///////////////////////////////////
// Author: Lucas M. Reia
// Original source: https://github.com/lucasmreia/fch
///////////////////////////////////

#pragma once

#include <Eigen/Dense>
#include <bitset>
#include <cstring>
#include <iostream>
#include <memory>
#include <vector>

#include "../common/bmi2.h"
#include "../common/utility.h"

// Check.
// With NDIM, we have 2^NDIM vertices in an n-hypercube.
// This cannot exceed the maximum size of size_t.
// The amount of RAM will run out well before that.
// I subtract 1 because if I shift by NDIM there has to be one bit left at the end.
static_assert(NDIM < ((sizeof(size_t) * 8) - 1));

// Label used to specify a face of the hypercube.
class Label2N : public BitLabel<2 * NDIM> {
   public:
    [[nodiscard]] size_t getMsb() const {
        BitLabel<2 * NDIM> aux;
        aux = *this;
        aux >>= NDIM;
        return aux.to_ullong();
    }

    [[nodiscard]] size_t getLsb() const {
        BitLabel<2 * NDIM> aux;
        aux = *this;
        aux &= ((1ULL << NDIM) - 1);
        return aux.to_ullong();
    }

    void getMsbAndLsb(size_t &msb, size_t &lsb) const {
        BitLabel<2 * NDIM> aux;
        aux = *this;
        aux >>= NDIM;
        msb = aux.to_ullong();
        aux = *this;
        aux &= ((1ULL << NDIM) - 1);
        lsb = aux.to_ullong();
    }

    void getFixedAndFreeCoord(size_t &fixed_coord, size_t &free_coord) const {
        size_t msb, lsb;
        getMsbAndLsb(msb, lsb);
        fixed_coord = msb | lsb;
        free_coord = fixed_coord ^ ((1ULL << NDIM) - 1);
    }

    void toVertexLabels(size_t *vert_hypercube) const {
        size_t msb, lsb;
        getMsbAndLsb(msb, lsb);
        const size_t fixed_coord = msb | lsb;
        const size_t free_coord = fixed_coord ^ ((1ULL << NDIM) - 1);
        const P_MASK mask = pmask(free_coord);
        const size_t n_vertices = (1ULL << std::popcount(free_coord));
        vert_hypercube[0] = msb;
        for (size_t i = 1; i < n_vertices; ++i) {
            vert_hypercube[i] = vert_hypercube[0] | pdep(i, mask);
        }
    }

    [[nodiscard]] size_t getDimension() const {
        size_t fixed_coord, free_coord;
        getFixedAndFreeCoord(fixed_coord, free_coord);
        return std::popcount(free_coord);
    }
};

// Hash for Label2N.
namespace std {
template <>
struct hash<Label2N> {
    size_t operator()(const Label2N &x) const {
        return std::hash<BitLabel<2 * NDIM>>()(x);
    }
};
}  // namespace std

// Cell generated by the GCMH.
struct HypercubeApprox {
    // vertices.
    std::vector<std::array<double, NDIM>> vertices;
    std::vector<std::array<size_t, KDIM + 1>> vertex_labels;
    // edges (connection between 2 vertices).
    std::vector<Label2N> edge_hface_labels;
    std::vector<std::array<size_t, 2>> edge_connections;

    void reset() {
        vertices.clear();
        vertex_labels.clear();
        edge_connections.clear();
        edge_hface_labels.clear();
    }
};

void genEdges(size_t dim,
              const std::vector<Label2N> &hface_labels,
              std::vector<std::vector<size_t>> &edge_connections,
              std::vector<Label2N> &edge_hface_labels);

// generalized combinatorial hypercube.
// returns a bool to inform if the generated approximation is valid.
bool gch(const std::array<std::array<double, NDIM>, (1ULL << NDIM)> &vert_hcube,
         HypercubeApprox &approx, Label2N &neighbor_cells);

void writeOutputHypercube(size_t g, const HypercubeApprox &approx, FILE *fout);

void readOutputHypercube(FILE *fin, HypercubeApprox &approx);

template <size_t DIM>
void vertLabelsToInductive(const std::array<size_t, DIM + 1> &vert_labels,
                           std::array<size_t, DIM> &e_idx) {
    for (size_t i = 0; i < DIM; ++i) {
        e_idx[i] = std::countr_zero(vert_labels[i + 1] - vert_labels[i]);
    }
}

template <size_t DIM>
void inductiveToVertLabels(const size_t first_vert_label,
                           const std::array<size_t, DIM> &e_idx,
                           std::array<size_t, DIM + 1> &vert_labels) {
    vert_labels[0] = first_vert_label;
    for (size_t i = 1; i <= DIM; ++i) {
        vert_labels[i] = vert_labels[i - 1] | (1ULL << e_idx[i - 1]);
    }
}

// based on the hypercube face label and the direction of the coface, inserts a vertex in the dim-simplex
// to make it a (dim+1)-simplex.
// returns the index, within the (dim+1)-simplex, of the new vertex added to the dim-simplex (either 0 or DIM+1).
// within the (k+1)-hypercube there is only one (k+1)-simplex that contains the k-simplex within the hypercube k-face.
template <size_t DIM>
size_t elevateDimension(const Label2N &in_hface_label, const std::array<size_t, DIM> &in_e_idx,
                        const size_t unset_bit_idx,
                        Label2N &out_hface_label, std::array<size_t, DIM + 1> &out_e_idx) {
    out_hface_label = in_hface_label;
    out_hface_label.reset(unset_bit_idx);
    const size_t unset_coord = unset_bit_idx % NDIM;
    if (unset_bit_idx < NDIM) {
        std::memcpy(out_e_idx.data(), in_e_idx.data(), DIM * sizeof(size_t));
        out_e_idx[DIM] = unset_coord;
        return (DIM + 1);  // last vertex of the (k+1)-simplex.
        // NOTE: IT'S THE POSITION OF THE LAST VERTEX, NOT THE LAST e_idx, SO IT'S +1.
    } else {
        out_e_idx[0] = unset_coord;
        std::memcpy(&out_e_idx[1], in_e_idx.data(), DIM * sizeof(size_t));
        return 0;  // first vertex of the (k+1)-simplex.
    }
}

// Get the index of the column that has to be pivoted.
// I already pass lu_decomp and lambda to reuse those values.
template <size_t DIM>
int64_t getPivotColumnIdx(const Eigen::PartialPivLU<Eigen::Matrix<double, DIM + 1, DIM + 1>> &lu_decomp,
                          const Eigen::Vector<double, DIM + 1> &lambda,
                          const Eigen::Vector<double, DIM + 1> &b_mu) {
    // solve the system to calculate mu.
    Eigen::Vector<double, DIM + 1> mu = lu_decomp.solve(b_mu);

    // calcualte min{lambda/mu} and the index of the vertex that must be replaced.
    double min_lambda_mu = 0;
    int64_t idx_k = -1;
    for (int64_t ii = 0; ii < (DIM + 1); ++ii) {
        if (mu(ii) > 0 && ((idx_k < 0) || (min_lambda_mu > lambda(ii) / mu(ii)))) {
            idx_k = ii;
            min_lambda_mu = lambda(ii) / mu(ii);
        }
    }
    //-- error check.
    if (idx_k < 0) {
        std::cout << "error idx_k: " << idx_k << std::endl;
        throw std::runtime_error("idx_k must be >= 0");
    }
    //--
    return idx_k;
}

// vertices, Vert_simplex_k_1 and extra_vertex_idx are progressively being modified as you pivot.
template <size_t DIM>
void traverseHCofaceHypercube(const std::array<std::array<double, NDIM>, (1ULL << NDIM)> &vert_hcube,
                              std::array<size_t, DIM + 2> &vert_labels_hc,
                              size_t &extra_vertex_idx) {
    // keep solving the system and pivoting until you find the output simplex.
    // create the system.
    Eigen::Matrix<double, DIM + 1, DIM + 1> A{};
    Eigen::Matrix<double, NDIM, DIM + 1> V{};
    std::array<size_t, DIM + 1> columns{};  // label of the vertex assigned to each column.

    // calculating the positions of the vertices and evalVertices.
    // creating the matrices of the A*x=b system.
    for (int64_t j = 0, v_idx = 0; j < (DIM + 1); ++j, ++v_idx) {
        if (v_idx == extra_vertex_idx) {
            ++v_idx;
        }
        columns[j] = v_idx;
        std::memcpy(&V(0, j), vert_hcube[vert_labels_hc[v_idx]].data(), NDIM * sizeof(double));
        A(0, j) = 1;
        func(vert_hcube[vert_labels_hc[v_idx]].data(), &A(1, j));
    }
    Eigen::Vector<double, DIM + 1> b_lambda = Eigen::Vector<double, DIM + 1>::Zero();
    b_lambda(0) = 1;

    // assigning b_mu.
    Eigen::Vector<double, DIM + 1> b_mu{};
    b_mu(0) = 1;
    func(vert_hcube[vert_labels_hc[extra_vertex_idx]].data(), &b_mu(1));

    // variables to solve the system.
    Eigen::Vector<double, DIM + 1> lambda{};
    Eigen::PartialPivLU<Eigen::Matrix<double, DIM + 1, DIM + 1>> lu_decomp;

    while (true) {
        // solve the system to compute lambda.
        lu_decomp = A.partialPivLu();
        lambda = lu_decomp.solve(b_lambda);

        const int64_t pivot_column_idx = getPivotColumnIdx<DIM>(lu_decomp, lambda, b_mu);
        if ((columns[pivot_column_idx] == 0) || (columns[pivot_column_idx] == (DIM + 1))) {
            // end of the traversal inside the coface.
            // extra vertex swapped with the vertex to be replaced.
            std::swap(columns[pivot_column_idx], extra_vertex_idx);
            return;
        }

        const size_t previous_v_idx = columns[pivot_column_idx] - 1;
        const size_t next_v_idx = columns[pivot_column_idx] + 1;
        const size_t dif_e = vert_labels_hc[next_v_idx] - vert_labels_hc[previous_v_idx];
        const size_t pivoted_v_label = vert_labels_hc[columns[pivot_column_idx]] ^ dif_e;

        // assign a new pivoted vertex.
        vert_labels_hc[columns[pivot_column_idx]] = pivoted_v_label;

        // replace the column pivot_column_idx with the extra_vertex_idx.
        std::swap(columns[pivot_column_idx], extra_vertex_idx);

        // updating b_mu with the new pivoted vertex.
        func(vert_hcube[vert_labels_hc[extra_vertex_idx]].data(), &b_mu(1));

        // updating the column with the replaced vertex.
        std::memcpy(&V(0, pivot_column_idx), vert_hcube[vert_labels_hc[columns[pivot_column_idx]]].data(),
                    NDIM * sizeof(double));
        func(vert_hcube[vert_labels_hc[columns[pivot_column_idx]]].data(), &A(1, pivot_column_idx));
    }
}
