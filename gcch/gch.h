///////////////////////////////////
// Author: Lucas M. Reia
// Original source: https://github.com/lucasmreia/fch
///////////////////////////////////

#pragma once

#include <Eigen/Dense>
#include <bitset>
#include <cstring>
#include <iostream>
#include <memory>
#include <vector>

#include "../common/bmi2.h"
#include "../common/utility.h"

// Label used to specify a face of the hypercube.
class Label2N : public BitLabel<2 * NDIM> {
   public:
    [[nodiscard]] size_t getMsb() const {
        BitLabel<2 * NDIM> aux;
        aux = *this;
        aux >>= NDIM;
        return aux.to_ullong();
    }

    [[nodiscard]] size_t getLsb() const {
        BitLabel<2 * NDIM> aux;
        aux = *this;
        aux &= ((1ULL << NDIM) - 1);
        return aux.to_ullong();
    }

    void getMsbAndLsb(size_t &msb, size_t &lsb) const {
        BitLabel<2 * NDIM> aux;
        aux = *this;
        aux >>= NDIM;
        msb = aux.to_ullong();
        aux = *this;
        aux &= ((1ULL << NDIM) - 1);
        lsb = aux.to_ullong();
    }

    void getFixedAndFreeCoord(size_t &fixed_coord, size_t &free_coord) const {
        size_t msb, lsb;
        getMsbAndLsb(msb, lsb);
        fixed_coord = msb | lsb;
        free_coord = fixed_coord ^ ((1ULL << NDIM) - 1);
    }
};

// Hash for Label2N.
namespace std {
template <>
struct hash<Label2N> {
    size_t operator()(const Label2N &x) const {
        return std::hash<BitLabel<2 * NDIM>>()(x);
    }
};
}  // namespace std

// Cell generated by the GCMH.
struct HypercubeApprox {
    // vertices.
    std::vector<std::array<double, NDIM>> vertices;
    std::vector<std::array<size_t, KDIM + 1>> vertex_labels;
    // edges (connection between 2 vertices).
    std::vector<Label2N> edge_hface_labels;
    std::vector<std::array<size_t, 2>> edge_connections;

    void reset() {
        vertices.clear();
        vertex_labels.clear();
        edge_connections.clear();
        edge_hface_labels.clear();
    }
};

void genEdges(size_t dim,
              const std::vector<Label2N> &hface_labels,
              std::vector<std::vector<size_t>> &edge_connections,
              std::vector<Label2N> &edge_hface_labels);

// generalized combinatorial hypercube.
// returns a bool to inform if the generated approximation is valid.
bool gch(const std::vector<std::array<double, NDIM>> &vert_hcube,
         HypercubeApprox &approx, Label2N &neighbor_cells);

void writeOutputHypercube(const size_t g,
                          const BitLabel<DOMAIN_DIV_TOTAL_BIT_WIDTH> &bitset_coord,
                          const HypercubeApprox &approx, FILE *fout);

void readOutputHypercube(FILE *fin,
                         BitLabel<DOMAIN_DIV_TOTAL_BIT_WIDTH> &bitset_coord,
                         HypercubeApprox &approx);
